---
layout: post
title: MySQL锁总结
description: MySQL锁总结
categories: MySQL
keywords: MySQL, 锁
---

# 锁的定义

- 锁机制用于管理对共享资源的并发访问；
- MyISAM引擎，其锁是表锁设计，并发情况下读没有问题，并发插入时的性能要差一些；
- latch一般称为闩锁（轻量级锁），因为其要求锁定的时间必须非常短，latch又分为mutex（互折量）和rwlock（读写锁）。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测机制；
- lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务提交或回滚后进行释放（不同事务隔离级别释放的时间可能不同）；

|   |  lock | latch  |
| :------------: | :------------: | :------------: |
|  对象 | 事务  | 线程  |
| 保护 | 数据库内容 | 内存数据结构 |
| 持续时间  |  整个事务过程 | 临界资源  |
| 模式  | 行锁、表锁、意向锁  |  读写锁、互斥量 |
|  死锁 | 通过waits-for graph、timeout等机制进行死锁检测与处理  | 无死锁检测与处理机制。仅通过应用程序加锁的顺序（locking leveling）保证无死锁的情况发生 |
|  存在于 | Lock Manager的哈希表中  | 每个数据结构的对象中|

# 锁的类型

## 行锁
innodb实现了两种标准的行级锁：

-  共享锁（S Lock)，允许事务读一行数据；
-  排他锁（X Lock), 允许事务删除或更新一行数据；

排他锁与共享锁的兼容性：

- 锁兼容：事务1已获得行R的共享锁，事务2可以立即获得行R的共享锁；
- 锁不兼容：事务3想获得行R的排他锁，则必须等待事务1和2释放行R上的共享锁；
- 注意：S锁和X锁都是行锁，兼容是指对同一记录锁的兼容情况；

|   | X  | S  |
| :------------: | :------------: | :------------: |
| X |  不兼容 |  不兼容 |
| S  |不兼容   | 兼容  |

## 意向锁
- 意向锁：将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁；
- 意向即为表级别的锁，设计的目的主要是为了在一个事务中提示下一行即将被请求的锁类型；
- 意向共享锁（IS Lock)，事务想要获得一张表中某几行的共享锁；
- 意向排他锁（IX Lock）,事务想要获得一张表中某几行的排他锁；
- show engine innodb status来查看当前锁请求的信息；

# 一致性非锁定读
- 定义：是指innodb存储引擎通过行多版本控制的方式来读取当前执行时间数据库中行的数据；
- 快照数据：是指该行的之前的版本数据，该实现通过undo段来完成。而undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销的。读取快照数据不需要上锁的，因为没有事务需要对历史数据进行修改操作；
- 并不是在每个事务隔离级别下都是采用非锁定一致性读；
- 一个行记录可能有不止一个快照数据，一般称这种技术为多版本技术。由此带来的并发控制，称之为多版本并发控制（MVCC)；
- 在read commited事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据；
- 在repeatable read事务隔离级别下，对于快照数据，非一致性读总是读取事务开始的行数据版本；
- Innodb存储引擎的SELECT操作使用一致性非锁定读；

# 一致性锁定读
- Innodb存储引擎对于SELECT语句支持两种一致性锁定读操作：
- SELECT … FOR UPDATE： 对读取的行记录加X锁，其他事务不能对已锁定的行加上任何锁。
- SELECT … LOCK IN SHARE MODE： 对读取的行记录加一个S锁，其他事务可以向被锁定的行加S锁，但是如果加X锁，则会被阻塞。
- 对于一致性非锁定读，即使读取的行已经被执行了SELECT .. FOR UPDATE，也是可以进行读取的；
- 上述两条SELECT锁定语句时，必须在一个事务中，当事务提交了，锁也就释放了，务必加上BEGIN,START TRANSACTIONA或者AUTOCOMMIT=0;

# 锁的算法

innodb存储引擎有3种行锁的算法：

- record lock: 单个记录上的锁；
- gap lock: 间隙锁，锁定一个范围，但不包含记录本身；

    > 1）innodb还会对辅助索引下一个键值加上gap lock；
    >
    > 2）gap lock的作用是为了阻止多个事务将记录插入到同一范围内，而这会导致phantom problem问题的产生；

- next-key lock: gap lock + record lock,锁定一个范围，并且锁定记录本身；

    > 1）对于行的查询都是采用这种锁定算法。设计的目的是为了解决phantom problem（幻读）;
    >
    > 2） 幻读：指同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。（违反事务隔离性即当前事务能看到其他事务的执行结果）；
    >		
    > 3）要验证幻读问题，可以在read-commited级别下，通过类似select * from xx where b >= 500 for update来验证；
    >
    > 4）例如一个索引有10，11，13，20这四种值，那么该索引可能被next-key locking的区间为：（负无穷,10]（10，11], (11, 13], (13, 20],(20,正无穷)
，与此相似还有previous-key locking: (负无穷,10), [10,11),[11,13),[13,20),[20,正无穷)；
    >
    > 5）当查询的索引含有唯一属性时，Innodb存储引擎会对next-key lock进行优化，将其降为record lock，即仅锁住索引本身，而不是范围；
    >		
    > 6）next-key lock降级为read lock仅在查询的列是唯一索引的情况下，若是辅助索引，则情况完不同；
    >
    > 7）若唯一索引由多个列组成，而查询仅是查找多个唯一索引列中的其中一个，那么查询其实是range类型查询，而不是point类型查询，所以依然使用next-key lock进行锁定；

# 锁的问题

## 脏读
- 脏数据是指事务对缓冲池中行记录的修改，并且还没有被提交。
- 脏数据是指未提交的数据，如果读到了脏数据，即一个事务可以读到另外一个事务中未提交的数据，显示违背了数据库的隔离性；
- 脏读指的就是在不同的事务下，当前事务可以读到另外一个事务未提交的数据，简单的来说就是读到脏灵气；


## 不可重复读
- 不可重复读是指在一个事务内多次读取同一数据集合。在这个事务还没有结束时，另外一个事务也访问该同一数据集合，并做了一些DML操作。因此，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次连续读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的情况，这种情况称为不可重复读；
- 不可重复读和脏读的区别是：脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据，但其违返了数据库事务一致性要求；

## 丢失更新问题
- 一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致；
- 注意数据库能阻止丢失更新问题的产生，但是生产应用中还有另一个逻辑意义的丢失更新问题，而不是本身数据库导致的；

## 死锁
- 死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。
- 死锁的检测方法：

    > a）超时：即两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行；
    >
    > b）用等待图：是一种主动死锁的检测机制，在每个事务请求锁发生等待时都会判断是否存在回路，若存在则有死锁，一般选择回滚undo量最小的事务；

- 系统中的事务数量（n），数量越多发生的死锁的概率越大；
- 每个事务操作的数量（r），每个事务操作的数量越多，发生的死锁概率越大；
- 操作数据的集合（R），越小则发生死锁的概率越小；
- 避免死锁：可以根据上面减少发生的概率的措施，以及按顺序去获取锁；
- 死锁只存在于并发的情况；
- Innodb存储引擎并不会回滚大部分的错误异常，但是死锁除外。发现死锁后，Innodb存储引擎会马上回滚一个事务；
- Innodb存储引擎不存在锁升级的问题。因为其不是根据每个记录来产生行锁的，相反，其根据每个事务访问的每个页对锁进行管理的，采用的是位图方式。因此不管一事事务锁住页中一个记录还是多个记录，其开销通常都是一致的；


