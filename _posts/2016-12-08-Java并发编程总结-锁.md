---
layout: post
title: Java并发编程总结-锁
description: Java并发编程总结-锁
categories: Java
keywords: java, 并发, github, 博客, m5jun
---


# 锁

* 变量的非独立性：某个变量的值会制约其他几个变量的值；
* 对于每个可被多线程访问的可变状态变量，如果所有访问它的线程在执行时都占有同一个锁，这种情况下，我们称为这个变量是由这个锁保护的。
* 锁保护的变量，意味着每一次访问变量时都要获得该锁，确保在同一时刻只有一个线程可以访问这个变量；
* 对于每一个涉及多个变量的不为约束，需要同一个锁保护其所有的变量；
* 缺少即加入（put-if-absent)

## 内部锁

* 内制锁机制：synchronized块；
* 内部锁或监视器锁：每个JAVA对象都可以隐式地扮演一个用于同步的锁的角色，这些内置的锁被称为内部锁或监视器锁；
* 获得内部锁的唯一途径是进入这个内部锁保护的同步块或方法；
* 内部锁在JAVA中扮演了互斥锁的角色；
* 内部锁是可重入的，因此线程在试图获得它占有的锁时，请求会成功。
* 可重入：线程在试图获得它自己已占有的锁时，请求会成功；
* 缺点：

    1）不能中断那些正在等待获取锁的线程，并且在请求锁失败的情况下，必须无限等待；
    2）死锁的唯一恢复方法是重启；


## 显示锁：
* Lock提供了无条件的、可轮询的、定时的、可中断的锁获取操作，所有加锁和解锁的方法都是显示的；
* ReentrantLock提供了与synchronized一样可重入加锁的语义；
* ReadWriteLock读写锁：一个资源能够被多个读者访问，或者被一个写者访问，两者不能同时进行；
* 读写锁的设计是用来进行性能改进的，使得特定情况下能够有更好的并发性；


## 内部锁与显示锁的比较
* 内部锁不能中断那些正在等待获取锁的线程，并且在请求锁失败的情况下，必须无限等待；
* 内部锁必须在获取它们的代码块中释放；
* 显示锁必须在finally块中释放；
* 显示锁具有更完善的错误恢复机制；死锁：内部锁唯一恢复方法是重启，唯一预防是在构建程序时不要出错； 显示锁可以规避死锁的发生；
* 内部锁相比于显示锁仍然具有很大的优势，使用更简单，简洁，当内部锁不能够满足使用时ReentrantLock才被作为高级的工具使用；
* 内部锁的线程转储能够显示哪些个调用框架获得了哪些锁，并能够识别发生了死锁的那些线程；
* synchronized是内置于JVM的，它能够进行优化；如锁的粗化等；


## 锁的公平性
* 在公平锁中，如果锁已经被其他线程占有，新的请求线程会加入到等待队列，或者已经有一些线程在等待锁了；
* 在非公平锁中，线程只有当锁正在被占用时才会等待；



# 锁在应用层的优化思路

## 减少持有锁的时间

* 通过把与锁无关的代码移出synchronized块来实现，比如那些阻塞操作IO;
* 减少锁的持有时间有助于降低锁冲突的可能性，进而提升系统的并发能力；

## 减小锁粒度
* 指减缩小锁定对象的范围，从而减少锁冲突的可能性；
* 典型的实现ConcurrentHashMap；
* 当系统需要取得全局锁时，其消耗的资源会比较多；如size();

## 锁分离
* 根据应用程序的功能特点，将一个独占锁分成多个锁；
* 典型实现LinkedBlockingQueue中的take和put操作；

## 减少请求锁的频率；
* 让线程减少调用它的频率（因此减小发生竞争的可能性）通过分拆锁和分离锁；
* 锁的分离的负作用：对容器加锁，进行独占访问更加困难，并且更加昂贵了，有些操作需要获取所有的锁；
* 热点域：如集合计算器每个变化操作都要访问它；

## 锁粗化
* 虚拟机在遇到一连串连续地对同一锁不断进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次请求，从而减少锁的请求同步次数，这叫锁的粗化；
* 如循环中获取锁，可以变为只在外层获取锁；

## CAS无锁
* JDK1.8引入LongAdder类来优化在高并发下原子变量竞争激烈条件下修改的失败概率很高，失败会多次尝试，性能受到影响；
* LongAddr类将执点数据进行分离、将value分离成一个数组，每个线程访问时，通过哈希方法映射到一个数字进行计数，最终结果则为这个数组累加求和；
* 类似ConcurrentHashMap分离热点域数据；

## 或者用协调机制取代独占锁，从而允许更强的并发性；
* readWriteLock：实现了一个多读者-单写者，加锁规则：只要没有更改，那么多个读者可以并发访问共享资源，但是写者必须独占获得锁；
* 原子变量；


# 虚拟机层面优化

## 偏向锁
* 核心思想：如果程序没有竞争，则取消之前已经获得锁的线程同步操作；
* 优点：在少竞争的情况下，对系统性能有一定帮助；
* 缺点：在锁竞争激烈的场合没有太强的优化效果；

## 轻量级锁
* 偏向锁失败，JVM会让线程申请轻量级锁；

## 锁膨胀
* 当轻量级锁失败，虚拟机会使用重量级锁。（monitor)

## 自旋锁
* 核心思想：使线程在没有获取锁时，不被挂起，而转而去执行一个空循环；
* 优点：适用锁竞争不激烈，锁占用时间很短的并发线程；
* 缺点：锁竞争激烈且单线程锁占用时间长的并发发程序，自旋锁在自旋等待后，往往依然无法获得对应的锁，白白浪费了CPU时间，被挂起
    
## 锁消除
* 核心思想：JAVA虚拟机在JTI编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。基于逃逸分析技术。比如sb.append()
* 优点：消除无意义的锁，节省无意义的锁请求时间；



   

