---
layout: post
title: JVM垃圾收集器和内存分配
description: JVM垃圾收集器和内存分配
categories: JVM
keywords: JVM, 垃圾收集器和, 内存分配, github, 博客, m5jun
---

总结下常见的JVM垃圾收集器。

# 串行回收器

定义：指用单线程进行垃圾回收的回收器；

串行回收器可以在新生代和老年代上使用；

## 新生代串行回收器
* 使用单线程进行垃圾回收；
* 它是独占式的垃圾回收；
* 使用复制算法，实现相对简单，逻辑处理特别高效，且没有线程切换的开销；
* 使用-XX:+UseSerialGC参数可以指定新生代串行收集器和老年代串行收集器；
        
## 老年代串行回收器
* 使用标记压缩算法；
* -XX:+UseParNewGC：新生代用ParNew回收器，老年代使用串行回收器；
* -XX:+UseParallelGC：新生代使用Parallel回收器，老年代使用串行回收器；
    
# 并行回收器
        
定义：使用多个线程同时进行垃圾回收；

## 新生代ParNew回收器
* 只是简单地将串行回收器多线程化；
* -XX:UseConcMarkSweepGC：新生代使用ParNew回收器，老年代用CMS；

## 新生代ParallelGC回收器
* 采用复制算法；
* -XX:+UseParallelOldGC：新生代使用Parallel回收器，老年代使用ParallelOld回收器；
* 它非常关注系统吞吐量；
    
## 老年代ParallelOldGc回收器
* 也是一种关注吞吐量的收集器；
* 标记压缩算法；
* 在JDK1.6中才可以使用；

# CMS回收器

注意：并发是指收集器和应用程序交替执行，并行是指应用程序停止，同时由多个线程一起执行GC。
因此并行回收器不是并发的，因为并行执行回收器执行时，应用程序挂起，不存在交替执行现象；

* 主要关注系统停顿时间；
* 使用标记清除算法；

# G1回收器
* 属于分代回收器；
* 采用分区算法；
* JDK1.7中正式使用；

# 内存分配
TLAB：线程本地分配缓存。

解决的问题：一般对象会分配在堆上，堆是全局共享。同一时间可能会有多个线程在堆上申请空间。
因此每一次分配必须要进行同步，而在竞争激烈的场合分配的效率又会进一步下降。TLAB来避免多线程冲突，提高对象分配效率。

* TLAB本身占用了eden的空间。
* 启用的情况下，每一个Java线程分配一个TLAB空间；
* 大对象无法在TLAB上进行分配，总是会直接分配在堆上；
    
      

    

