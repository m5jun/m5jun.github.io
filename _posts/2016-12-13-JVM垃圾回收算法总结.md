---
layout: post
title: JVM垃圾回收算法总结
description: JVM垃圾回收算法总结
categories: JVM
keywords: java, jvm, 垃圾回收算法, github, 博客, m5jun
---

# 名词解释

可达对象：指通过根对象进行引用搜索，最终可以达到的对象；

不可达对象：通过根对象进行引用搜索，最终没有被引用到的对象；

新生代：存放年轻代对象的堆空间；

老年代：存放老年对象的堆空间；

年轻对象：指刚刚创建的，或者经历垃圾次数不多的对象；

老年对象：指经历过多次垃圾回收依然存活的对象；

# 基本算法

## 引用记数法

* 无法处理循环引用问题；
* 引用计算器要求在每次产生和消除的时候需要伴随一个加法操作和减法操作，对系统性能有一定影响；

## 标记清除法
* 标记阶段：标记可达对象，未被标记的对象是不可达对象；
* 清除阶段：清除所有未被标记的对象；
* 容易产生空间碎片；

## 复制算法
* 将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后清除正在使用的内存块中的对象，交换两个内存的角色，完成垃圾回收；
* 垃圾对象比较多的情况，复制算法效率非常高，因为复制的存活对象相对比较少；
* 不会产生内存碎片问题；
* 代价是将系统内存折半；
* Java新生代串行垃圾回收器中，使用了复制算法的思想；

## 标记压缩法
* 是一种老年代回收算法；
* 首先从根节点开始，对所有可达对象进行标记，然后将存活对象压缩到内存的一端，之后清理边界外的空间；
* 避免了内存碎片的产生，又不需要两块相同的内存空间；
* 等价于标记清除算法执行完成后，再进行一次内存碎片整理；

## 分代算法
* 将内存区间根据对象的特点分成几块，根据每块的内存区间特点，使用不同的回收算法，以提高回收的效率；
* 新生代对象朝生夕灭、回收频率高，采用复制算法；
* 老年代对象存活时间久、回收频率低，采用标记压缩或标记清除算法；

## 分区算法
* 将整个堆空间分成连续不同的小区间；
* 每一个小区间独立使用，独立回收；
* 可以控制一次回收多少个小区间；
* 根据目标停顿的时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿；

# 判断可触及性

可触及性：从根节点开始是否可以访问到这个对象，如果可以，则说明当前对象正在被使用，如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了。

可触及性包含以下状态：
* 可触及的：从根节点开始，可以到达这个对象；
* 可复活的：对象的所有引用都被释放，但是对象有可能在finalize()函数中复活；

不可触及的：对象的finalize()函数被调用，并且没有复活，那么就会进入不可触及的状态；不可触及的对象不可能被复活，因为finalize()函数只会被调用一次；

## 引用

### 强引用
* 可以直接访问目标对象；
* 强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向的对象；
* 强引用可能导致内存泄露；

### 软引用
* 一个对象只持有软引用，那么当堆空间不足时就会被回收；
* GC未必会回收软引用对象，但是当内存资源紧张时，软引用对象会被回收，所以软引用对象不会引起内存溢出；
* 每一个软引用都可以附带一个引用队列，当对象的可达性状态发生改变时（由可达变为不可达）软引用对象会进入引用队列，通过引用队列可以跟踪对象的回收情况；
    
### 弱引用
* 在系统GC时，只要发现弱引用，不管系统堆空间使用情况如何，都会将对象进行回收；
* 类似软引用，一旦一个弱引用对象被垃圾回收器回收，但会加入到一个注册的引用队列中；
* 软引用、弱引用都非常适合来保存那些可有可无的缓存数据；

### 虚引用
* 一个持有虚引用的对象和没有引用几乎是一样的，随时可能被垃圾回收器回收；
* 虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程；

# Stop-The-World
停顿的目的：终止所有应用线程的执行，只有这样，系统中才不会有新的垃圾产生，同时停顿保证了系统状态在某一瞬间的一致性，也有益于垃圾回收器更好地标记对象；
        



