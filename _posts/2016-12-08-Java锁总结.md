---
layout: post
title: Java锁总结
description: Java锁总结
categories: 锁
keywords: java, 锁
---



# 锁的基本定义

- **变量的非独立性**：某个变量的值会制约其他几个变量的值；
- 对于每个可被多线程访问的可变状态变量，如果所有访问它的线程在执行时都占有同一个锁，这种情况下，我们称为这个变量是由这个**锁保护**的。
- 锁保护的变量，意味着每一次访问变量时都要获得该锁，确保在同一时刻只有一个线程可以访问这个变量；
- 锁的公平性：在公平锁中，如果锁已经被其他线程占有，新的请求线程会加入到等待队列，或者已经有一些线程在等待锁了；在非公平锁中，线程只有当锁正在被占用时才会等待；

# 锁的基本分类

## 内部锁
- 内制锁机制：synchronized块；
- **内部锁或监视器锁**：每个JAVA对象都可以隐式地扮演一个用于同步的锁的角色，这些内置的锁被称为内部锁或监视器锁；
- 获得内部锁的**唯一途径**是进入这个内部锁保护的同步块或方法；
- 内部锁在JAVA中扮演了互斥锁的角色；
- 内部锁是**可重入**的，因此线程在试图获得它占有的锁时，请求会成功。
- **可重入**：线程在试图获得它自己已占有的锁时，请求会成功；
		
## 显示锁：
- Lock提供了无条件的、可轮询的、定时的、可中断的锁获取操作，所有加锁和解锁的方法都是显示的；
- ReentrantLock提供了与synchronized一样可重入加锁的语义；
- ReadWriteLock读写锁：**一个资源能够被多个读者访问，或者被一个写者访问，两者不能同时进行；**
- 读写锁的设计是用来进行性能改进的，使得特定情况下能够有更好的并发性；

## 内部锁与显示锁的比较：
- 内部锁不能中断那些正在等待获取锁的线程，并且在请求锁失败的情况下，必须无限等待；
- 内部锁必须在获取它们的代码块中释放；
- 显示锁必须在finally块中释放；
- 显示锁具有更完善的错误恢复机制；死锁：内部锁唯一恢复方法是重启，唯一预防是在构建程序时不要出错； 显示锁可以规避死锁的发生；
- 内部锁相比于显示锁仍然具有很大的优势，使用更简单，简洁，当内部锁不能够满足使用时ReentrantLock才被作为高级的工具使用；
- 内部锁的线程转储能够显示哪些个调用框架获得了哪些锁，并能够识别发生了死锁的那些线程；
- synchronized是内置于JVM的，它能够进行优化；如锁的粗化等；

# 锁的优化

## 锁在应用层的优化思路

### 减少持有锁的时间
- 通过把与锁无关的代码移出synchronized块来实现，比如那些阻塞操作IO;
- 减少锁的持有时间有助于降低锁冲突的可能性，进而提升系统的并发能力；

### 减小锁粒度
- 指减缩小锁定对象的范围，从而减少锁冲突的可能性；
- 典型的实现ConcurrentHashMap；
- 当系统需要取得全局锁时，其消耗的资源会比较多，如size();

### 锁分离
- 根据应用程序的功能特点，将一个独占锁分成多个锁；
- 典型实现LinkedBlockingQueue中的take和put操作；

### 减少请求锁的频率；
- 让线程减少调用它的频率（因此减小发生竞争的可能性）通过分拆锁和分离锁；
- 锁的分离的负作用：对容器加锁，进行独占访问更加困难，并且更加昂贵了，有些操作需要获取所有的锁；
- 热点域：如集合计算器每个变化操作都要访问它；

### CAS无锁
- JDK1.8引入LongAdder类来优化在高并发下原子变量竞争激烈条件下修改的失败概率很高，失败会多次尝试，性能受到影响；
- LongAddr类将执点数据进行分离、将value分离成一个数组，每个线程访问时，通过哈希方法映射到一个数字进行计数，最终结果则为这个数组累加求和；
- 类似ConcurrentHashMap分离热点域数据；

### 或者用协调机制取代独占锁，从而允许更强的并发性；
- readWriteLock：实现了一个多读者-单写者，加锁规则：只要没有更改，那么多个读者可以并发访问共享资源，但是写者必须独占获得锁；
- 原子变量；

## 虚拟机层面优化

### 偏向锁
- 核心思想：如果程序没有竞争，则取消之前已经获得锁的线程同步操作；
- 优点：在少竞争的情况下，对系统性能有一定帮助；
- 缺点：在锁竞争激烈的场合没有太强的优化效果；

### 轻量级锁
- 偏向锁失败，JVM会让线程申请轻量级锁；

### 锁膨胀
- 当轻量级锁失败，虚拟机会使用重量级锁。（monitor)

### 自旋锁
- 核心思想：使线程在没有获取锁时，不被挂起，而转而去执行一个空循环；
- 优点：适用锁竞争不激烈，锁占用时间很短的并发线程；
- 缺点：锁竞争激烈且单线程锁占用时间长的并发发程序，自旋锁在自旋等待后，往往依然无法获得对应的锁，白白浪费了CPU时间，被挂起

### 锁消除
- 核心思想：JAVA虚拟机在JTI编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。基于逃逸分析技术。比如sb.append()
- 优点：消除无意义的锁，节省无意义的锁请求时间；

### 锁粗化
- 虚拟机在遇到一连串连续地对同一锁不断进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次请求，从而减少锁的请求同步次数，这叫锁的粗化；
- 如循环中获取锁，可以变为只在外层获取锁；